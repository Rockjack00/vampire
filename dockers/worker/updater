#!/usr/bin/env python3

import json
import logging
import os
import socket
import threading
import uuid
import time

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

class WorkerStatusUpdater(threading.Thread):
    """Thread that runs in the background publishing worker READY status"

    def __init__(self):
        threading.Thread.__init__(self)
        self.logger = logging.getLogger("WorkerStatusUpdater")
        self.logger.setLevel(logging.DEBUG)
        self.setDaemon(True)
        self.logger.info("WorkerStatusUpdater started")

    def check_process_status():
        status = 'READY'
        output = subprocess.check_output(['ps', 'ax', '-ocomm']).decode("utf-8").strip()

        if 'orted' in output:
            status = 'BUSY'
    
        if 'sshd' not in output:
            status = 'ERROR'

        if 'vampire' in output:
          logger.info("Vampire detected")

        return status


    def write_status(status):
        data = {"status": status, "timestamp": int(time.time())}
        with open(
                "/competition/worker_node_status.json",
                "w+",
        ) as statusfile:
            statusfile.write(json.dumps(data))

    def run(self): 
        while True: 
            status = check_process_status()
            write_status(status)
            self.logger.info("Worker updated status")
            time.sleep(1)

def run_updater(path):
    cmd = os.path.join(path, "leader")
    stdout = os.path.join(path, "leader_stdout.log")
    stderr = os.path.join(path, "leader_stderr.log")
    with open(stdout, "wb") as out, open(stderr, "wb") as err:
        subprocess.Popen(cmd, stdout=out, stderr=err)

if __name__ == "__main__":
    logger = logging.getLogger("Worker")
    logger.setLevel(logging.INFO)
    logger.info("Worker started") 
    write_status('READY')
    os.system("worker_vampire.sh")
    logger.info("Worker vampire started")
    update_worker_status()
